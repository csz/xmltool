{"name":"Mycila XML Tool","tagline":"XML manipulation library in Java built on a Fluent API","body":"**Table of Contents**\r\n\r\n- [Mycila XML Tool](#mycila-xml-tool)\r\n\t- [Maven Repository](#maven-repository)\r\n\t- [Documentation](#documentation)\r\n\t\t- [Creating XML documents](#creating-xml-documents)\r\n\t\t\t- [Creating a new XML document](#creating-a-new-xml-document)\r\n\t\t\t- [Loading an existing XML document](#loading-an-existing-xml-document)\r\n\t\t\t- [Ignoring namespaces](#ignoring-namespaces)\r\n\t\t- [Using namespaces](#using-namespaces)\r\n\t\t\t- [Adding and retrieving namespaces and prefixes](#adding-and-retrieving-namespaces-and-prefixes)\r\n\t\t\t- [Prefix constraints](#prefix-constraints)\r\n\t\t- [XML elements operations](#xml-elements-operations)\r\n\t\t\t- [On elements](#on-elements)\r\n\t\t\t- [On attributes](#on-attributes)\r\n\t\t\t- [On text and data](#on-text-and-data)\r\n\t\t- [Navigation, XPath and Callback support](#navigation-xpath-and-callback-support)\r\n\t\t\t- [Raw XPath](#raw-xpath)\r\n\t\t\t- [Gotos](#gotos)\r\n\t\t\t- [Callbacks on selected nodes](#callbacks-on-selected-nodes)\r\n\t\t- [Converting your XML document](#converting-your-xml-document)\r\n\t\t- [Validating your XML document](#validating-your-xml-document)\r\n\t\t- [Exception handling](#exception-handling)\r\n\r\n# Mycila XML Tool #\r\n\r\nXMLTool is a very simple Java library to be able to do all sorts of common operations with an XML document. As a Java developer, I often end up writing the always the same code for processing XML, transforming, ... So i decided to put all in a very easy to use class using the Fluent Interface pattern to facilitate XML manipulations.\r\n\r\n    XMLTag tag = XMLDoc.newDocument(false)\r\n        .addDefaultNamespace(\"http://www.w3.org/2002/06/xhtml2/\")\r\n        .addNamespace(\"wicket\", \"http://wicket.sourceforge.net/wicket-1.0\")\r\n        .addRoot(\"html\")\r\n        .addTag(\"wicket:border\")\r\n        .gotoRoot().addTag(\"head\")\r\n        .addNamespace(\"other\", \"http://other-ns.com\")\r\n        .gotoRoot().addTag(\"other:foo\");\r\n    System.out.println(tag.toString());\r\n\r\n__Features__\r\n\r\nWith XML Tool you will be able to quickly:\r\n\r\n * Create new XML documents from external sources or new document from scrash\r\n * Manage namespaces\r\n * Manipulating nodes (add, remove, rename)\r\n * Manipulating data (add, remove text or CDATA)\r\n * Navigate into the document with shortcuts and XPath (note: XPath supports namespaces)\r\n * Tranform an XMlDoc instance to a String or a Document\r\n * Validate your document against schemas\r\n * Executin callbacks on a hierarchy\r\n * Remove all namspaces (namespace ignoring)\r\n * ... and a lot of other features !\r\n\r\n__Project status__\r\n\r\n - __Issues:__ https://github.com/mycila/xmltool/issues\r\n - __OSGI Compliant:__ <img width=\"100px\" src=\"http://www.sonatype.com/system/images/W1siZiIsIjIwMTMvMDQvMTIvMTEvNDAvMzcvMTgzL05leHVzX0ZlYXR1cmVfTWF0cml4X29zZ2lfbG9nby5wbmciXV0/Nexus-Feature-Matrix-osgi-logo.png\" title=\"OSGI Compliant\"></img>\r\n - __Build Status:__ [![Build Status](https://travis-ci.org/mycila/xmltool.png?branch=master)](https://travis-ci.org/mycila/xmltool)\r\n\r\n## Maven Repository ##\r\n\r\n __Releases__\r\n\r\nAvailable in Maven Central Repository: http://repo1.maven.org/maven2/com/mycila/mycila-xmltool/\r\n\r\n__Snapshots__\r\n \r\nAvailable in OSS Repository:  https://oss.sonatype.org/content/repositories/snapshots/com/mycila/mycila-xmltool/\r\n\r\n__Maven dependency__\r\n\r\n    <dependency>\r\n        <groupId>com.mycila</groupId>\r\n        <artifactId>mycila-xmltool</artifactId>\r\n        <version>X.Y.ga</version>\r\n    </dependency>\r\n\r\n__Maven sites__\r\n\r\n - [4.0.ga] (http://mycila.github.io/xmltool/reports/4.0.ga/index.html)\r\n\r\n## Documentation ##\r\n\r\n### Performance consideration ###\r\n\r\nXML Tool uses the Java DOM API and `Document` creation has a cost. Thus, to improve peformance, XML Tool uses 2 Object pools of `DocumentBuilder` instances: \r\n\r\n* one pool for namespace-aware document builders\r\n* another one ignoring namespaces\r\n\r\nYou can configure the pools by using `XMLDocumentBuilderFactory.setPoolConfig(config)`\r\n\r\nBy default, each of the 2 pools have the following configuration:\r\n\r\n* min idle = 0\r\n* max idle = CPU core number\r\n* max total = CPU core number * 4\r\n* max wait time = -1\r\n\r\nIf your application is heavily threaded and a lot of threads are using XMLTag concurrently, to avoid thread contention you might want to increase the max total to match your peak thread count and max idle to match your average thread count.\r\n\r\nIf your application does not use a lot of thread and often create documents, you could probably lower those numbers.\r\n\r\nThe goal is to have sufficient `DocumentBuilder` instances available in the pool to be able to \"feed\" your application as demand without waiting for these objects to become available.\r\n\r\nUsing an object pool is sure much more complicated, but it will prevent any threading issues and also maximize performance because of object reuse.\r\n\r\n### Creating XML documents ###\r\n\r\n#### Creating a new XML document ####\r\n\r\nThe `newDocument` method crate a new XML document. You then have to choose a default namespace if you want and then choose the root name of the document.\r\n\r\n    System.out.println(XMLDoc.newDocument(true).addRoot(\"html\").toString());\r\n\r\ngives:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n    <html/>\r\n\r\n#### Loading an existing XML document ####\r\n\r\nThe `from` methods can load an XML document from any of the following types:\r\n\r\n * org.w3c.dom.Node\r\n * InputSource\r\n * Reader\r\n * InputStream\r\n * File\r\n * URL\r\n * String\r\n * javax.xml.transform.Source\r\n\r\n__Example:__\r\n\r\n    URL yahooGeoCode = new URL(\"http://local.yahooapis.com/MapsService/V1/geocode?appid=YD-9G7bey8_JXxQP6rxl.fBFGgCdNjoDMACQA--&state=QC&country=CA&zip=H1W3B8\");\r\n    System.out.println(XMLDoc.from(yahooGeoCode, true).toString());\r\n    System.out.println(XMLDoc.from(yahooGeoCode, true).getText(\"Result/City\"));\r\n\r\noutputs:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n    <ResultSet xmlns=\"urn:yahoo:maps\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"urn:yahoo:maps http://api.local.yahoo.com/MapsService/V1/GeocodeResponse.xsd\">\r\n    <Result precision=\"zip\">\r\n        <Latitude>45.543289</Latitude>\r\n        <Longitude>-73.543098</Longitude>\r\n        <Address/>\r\n        <City>Montreal</City>\r\n        <State>QC</State>\r\n        <Zip>H1W 3B8</Zip>\r\n        <Country>CA</Country>\r\n    </Result>\r\n    </ResultSet>\r\n    <!-- ws04.search.re2.yahoo.com uncompressed Tue Dec  9 13:39:12 PST 2008 -->\r\n    \r\n    Montreal\r\n\r\n#### Ignoring namespaces ####\r\n\r\nAll creational methods `XMLDoc.newDocument` and `XMLDoc.from` requires a boolean attribute `ignoreNamespaces`. If this attribute is set to true, all namespaces in the document are ignored. This is really useful if you use XPath a lot since you can avoid prefixing all your XPath elements.\r\n\r\n__Example:__\r\n\r\n    System.out.println(XMLDoc.newDocument(true)\r\n        .addDefaultNamespace(\"http://www.w3.org/2002/06/xhtml2/\")\r\n        .addRoot(\"html\"));\r\n    System.out.println(XMLDoc.newDocument(false)\r\n        .addDefaultNamespace(\"http://www.w3.org/2002/06/xhtml2/\")\r\n        .addRoot(\"html\"));\r\n\r\noutputs:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n    <html/>\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n    <html xmlns=\"http://www.w3.org/2002/06/xhtml2/\"/>\r\n\r\nNavigating in a document with namespaces using XPath is quite a pain:\r\n\r\n    doc.gotoTag(\"ns0:body\").addTag(\"child\")\r\n       .gotoParent().addCDATA(\"with special characters\")\r\n       .gotoTag(\"ns0:body\").addCDATA(\"<\\\"!@#$%'^&*()>\")\r\n\r\nwhereas if you load the same document with `ignoreNamespaces`, you can simply navigate like this when you use XPath:\r\n\r\n    doc.gotoTag(\"body\").addTag(\"child\")\r\n       .gotoParent().addCDATA(\"with special characters\")\r\n       .gotoTag(\"body\").addCDATA(\"<\\\"!@#$%'^&*()>\")\r\n\r\n### Using namespaces ###\r\n\r\nWhen you create or load a document, and if you decide to not ignore namespaces, you can add a default namespace for your document and add other ones after. Namespace management is quite a challenge, specifically when using XPath. When you have an XMLTag instance, you have access to the following methods to manage namespaces in the document:\r\n\r\n#### Adding and retrieving namespaces and prefixes ####\r\n\r\n__addDefaultNamespace__\r\n\r\nWhen you create an empty document, you can define a default namespace to use for the document. In example:\r\n\r\n    XMLTag doc = XMLDoc.newDocument()\r\n        .addDefaultNamespace(\"http://www.w3.org/2002/06/xhtml2/\")\r\n        .addRoot(\"html\");\r\n\r\nwill produce:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n    <html xmlns=\"http://www.w3.org/2002/06/xhtml2/\"/>\r\n\r\n__addNamespace__\r\n\r\nWhen you obtained an XMLTag instance, you can add any namespace you want. In example:\r\n\r\n    XMLTag doc = XMLDoc.newDocument()\r\n        .addDefaultNamespace(\"http://www.w3.org/2002/06/xhtml2/\")\r\n        .addNamespace(\"wicket\", \"http://wicket.sourceforge.net/wicket-1.0\")\r\n        .addRoot(\"html\")\r\n        .addTag(\"wicket:border\")\r\n        .gotoRoot().addTag(\"head\")\r\n        .addNamespace(\"other\", \"http://other-ns.com\")\r\n        .gotoRoot().addTag(\"other:foo\");\r\n\r\nwill produce:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n    <html xmlns=\"http://www.w3.org/2002/06/xhtml2/\">\r\n        <wicket:border xmlns:wicket=\"http://wicket.sourceforge.net/wicket-1.0\"/>\r\n        <head/>\r\n        <other:foo xmlns:other=\"http://other-ns.com\"/>\r\n    </html>\r\n\r\n__Namespace prefix generation__\r\n\r\nWhen you load an existing XML document, or when you define a default namespace in a new document, prefixes and namespaces are automatically found in the whole document. Often, XML documents have default namespace. This is often the case for example in XHTML documents, like below. For this case, XMLDoc will generate for you a prefix that you can use for XPath navigation, and register the namespace as being the default one.\r\n\r\nIn example, the following document will have a default namespace and also a prefix generated to access it: `ns0`.\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n    <html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\">\r\n        <head>\r\n            <title/>\r\n        </head>\r\n        <body/>\r\n    </html>\r\n\r\n    XMLTag doc = XMLDoc.from(...);\r\n    assertEquals(doc.getPrefix(\"http://www.w3.org/1999/xhtml\"), \"ns0\");\r\n    assertEquals(doc.getContext().getNamespaceURI(\"ns0\"), \"http://www.w3.org/1999/xhtml\");\r\n\r\nThe prefix 'ns0' has been generated in the namespace context of the document so that XPath expression can use it.\r\n\r\nYou can access the javax.xml.namespace.NamespaceContext like this:\r\n\r\n    NamespaceContext ctx = doc.getContext();\r\n\r\n#### Prefix constraints ####\r\n\r\nYou cannot override an already defined prefix in a context, and you cannot override default XML prefixes. The following 3 attempts will throw an exception:\r\n\r\n    // these prefixes are reserved\r\n    XMLDoc.newDocument().addRoot(\"html\").addNamespace(\"xml\", \"http://ns0\");\r\n    XMLDoc.newDocument().addRoot(\"html\").addNamespace(\"xmlns\", \"http://ns0\");\r\n    \r\n    // shows namespace generation prefix: when we add default prefix, 'ns0' is also created (or another if it already exists). So we cannot bind another namespace to this prefix.\r\n    XMLDoc.newDocument()\r\n        .addDefaultNamespace(\"http://def\")\r\n        .addRoot(\"html\")\r\n        .addNamespace(\"ns0\", \"http://ns0\");\r\n\r\n### XML elements operations ###\r\n\r\n#### On elements ####\r\n\r\nOperations affecting elements: `hasTag`, `addTag`, `getCurrentTag`, `getCurrentTagName`, `deleteChilds`, `delete`, `renameTo`\r\n\r\n__hasTag__\r\n\r\nCheck for the existence of a tag.\r\n\r\n__addTag__\r\n\r\nCreate a new tag\r\n\r\n    System.out.println(XMLDoc.newDocument(true)\r\n            .addRoot(\"html\")\r\n            .addTag(\"head\")\r\n            .toString());\r\n\r\noutputs:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n    <html>\r\n        <head/>\r\n    </html>\r\n\r\n__getCurrentTag__\r\n\r\nReturns the current `org.w3c.dom.Element`.\r\n\r\n__getCurrentTagName__\r\n\r\nReturns the current tag name.\r\n\r\n    System.out.println(XMLDoc.newDocument(true).addRoot(\"html\").getCurrentTagName());\r\n\r\noutputs:\r\n\r\n    html\r\n\r\n__delete__\r\n\r\nDeletes the current tag. The parent tag of the deleted tag becomes  one the current tag. If we call delete on the root tag, an exception is thrown. Root node can only be renamed.\r\n\r\n    System.out.println(XMLDoc.newDocument(true)\r\n            .addRoot(\"html\")\r\n            .addTag(\"head\")\r\n            .delete()\r\n            .toString());\r\n\r\noutputs:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n    <html/>\r\n\r\n__deleteChilds__\r\n\r\nDeletes all tags under the current tag.\r\n\r\n    System.out.println(XMLDoc.newDocument(true)\r\n            .addRoot(\"html\")\r\n            .addTag(\"head\").addTag(\"title\")\r\n            .toString());\r\n    System.out.println(XMLDoc.newDocument(true)\r\n            .addRoot(\"html\")\r\n            .addTag(\"head\").addTag(\"title\")\r\n            .gotoRoot().deleteChilds()\r\n            .toString());\r\n\r\noutputs:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n    <html>\r\n        <head>\r\n            <title/>\r\n        </head>\r\n    </html>\r\n    \r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n    <html/>\r\n\r\n__renameTo__\r\n\r\nRename a tag to another name.\r\n\r\n    System.out.println(XMLDoc.newDocument(true)\r\n        .addRoot(\"html\")\r\n        .renameTo(\"xhtml\")\r\n        .toString());\r\n\r\noutputs:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n    <html/>\r\n\r\n#### On attributes ####\r\n\r\nOperations affecting elements: `hasAttribute`, `getAttributeNames`, `getAttribute`, `deleteAttributes`, `deleteAttribute`\r\n\r\nSupposing we load the following XML file:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n    <!DOCTYPE html\r\n            PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\r\n            \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\r\n    <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\r\n    <head>\r\n        <title>my title</title>\r\n    </head>\r\n    <body>\r\n        <div id=\"header\" class=\"banner\"></div>\r\n        <div id=\"content\" class=\"cool\"></div>\r\n        <div id=\"footer\" class=\"end\"></div>\r\n    </body>\r\n    </html>\r\n\r\n__hasAttribute__\r\n\r\nCheck for the existence of an attribute.\r\n\r\n__getAttributeNames__\r\n\r\nReturns a list of attribute names of the current tag.\r\n\r\n    String[] names = XMLDoc.from(resource(\"test.xhtml\"), true)\r\n            .gotoTag(\"body/div[1]\")\r\n            .getAttributeNames();\r\n    System.out.println(Arrays.toString(names));\r\n\r\noutputs:\r\n\r\n    [class, id]\r\n\r\n__getAttribute__\r\n\r\nReturns an attribute value of the current tag or the selected tag by the XPath expression. If the attribute does not exist, throws an exception.\r\n\r\n    System.out.println(XMLDoc.from(resource(\"test.xhtml\"), true)\r\n            .gotoTag(\"body/div[1]\")\r\n            .getAttribute(\"class\"));\r\n    System.out.println(XMLDoc.from(resource(\"test.xhtml\"), true)\r\n            .getAttribute(\"class\", \"body/div[2]\"));\r\n\r\noutputs:\r\n\r\n    banner\r\n    cool\r\n\r\n__deleteAttributes__\r\n\r\nDeletes all attributes of a the current tag.\r\n\r\n    System.out.println(XMLDoc.from(resource(\"test.xhtml\"), true)\r\n        .gotoTag(\"body/div[1]\")\r\n        .deleteAttributes()\r\n        .toString());\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n    <html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">\r\n    <head>\r\n        <title>my title</title>\r\n    </head>\r\n    <body>\r\n        <div/>\r\n        <div class=\"cool\" id=\"content\"/>\r\n        <div class=\"end\" id=\"footer\"/>\r\n    </body>\r\n    </html>\r\n\r\n__deleteAttribute__\r\n\r\nDeletes a specific attribute. If it does not exist, an exception is thrown.\r\n\r\n    System.out.println(XMLDoc.from(getClass().getResource(\"/test.xhtml\"), true)\r\n            .hasAttribute(\"id\", \"body/div[1]\"));\r\n    System.out.println(XMLDoc.from(getClass().getResource(\"/test.xhtml\"), true)\r\n            .gotoTag(\"body/div[1]\").deleteAttribute(\"id\")\r\n            .hasAttribute(\"id\"));\r\n\r\n    true\r\n    false\r\n\r\n#### On text and data ####\r\n\r\nOperations affecting elements: `addText`, `addCDATA`, `getAttribute`, `deleteAttributes`, `deleteAttribute`\r\n\r\n__addText__, __addCDATA__\r\n\r\nAdds text or CDATA sections to the document. As you have seen above, you can mix text, data and tags under one tag. When we add text or data, the current tag automatically becomes the parent tag. This behavior facilitate document creation since most of the time you will have to add one text or one data per tag like this:\r\n\r\n    System.out.println(XMLDoc.newDocument(true)\r\n        .addRoot(\"html\")\r\n        .addTag(\"head\").addText(\"<\\\"!@#$%'^&*()>\")\r\n        .addTag(\"body\").addCDATA(\"<\\\"!@#$%'^&*()>\")\r\n        .toString());\r\n\r\nwhich gives:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n    <html>\r\n        <head>&lt;\"!@#$%'^&amp;*()&gt;</head>\r\n        <body><![CDATA[<\"!@#$%'^&*()>]]></body>\r\n    </html>\r\n\r\n__getText__, __getCDATA__\r\n\r\nReturns the text or data contained in the current tag or the targetted tag with the XPath expression. If the tag has no text, returns \"\".\r\n\r\nGiven:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n    <html xmlns=\"http://www.w3.org/2002/06/xhtml2/\" xmlns:ns0=\"http://wicket.sourceforge.net/wicket-1.0\">\r\n        <head>\r\n            <title ns0:id=\"titleID\">my special title: &lt;\"!@#$%'^&amp;*()&gt;</title>\r\n        </head>\r\n        <body>\r\n            <![CDATA[my special data: ]]>\r\n            <ns0:border>\r\n                <div/>\r\n                child1\r\n            </ns0:border>\r\n            <ns0:border>child2</ns0:border>\r\n            <![CDATA[<\"!@#$%'^&*()>]]>\r\n            <ns0:border>child3</ns0:border>\r\n        </body>\r\n    </html>\r\n\r\nThe following assertions are true:\r\n\r\n    assertEquals(doc.getCurrentTag().getNodeType(), Document.ELEMENT_NODE);\r\n    assertEquals(doc.getCurrentTagName(), \"html\");\r\n    assertEquals(doc.getCurrentTagName(), \"html\");\r\n    assertEquals(doc.getPefix(\"http://www.w3.org/2002/06/xhtml2/\"), \"ns1\"); // ns0 is already used in the document\r\n    assertEquals(doc.gotoTag(\"ns1:head/ns1:title\").getText(), \"my special title: <\\\"!@#$%'^&*()>\");\r\n    assertEquals(doc.getText(\".\"), \"my special title: <\\\"!@#$%'^&*()>\");\r\n    assertEquals(doc.getCDATA(\"../../ns1:body\"), \"my special data: <\\\"!@#$%'^&*()>\");\r\n    assertEquals(doc.getAttribute(\"ns0:id\"), \"titleID\");\r\n\r\nNB: we loaded the document by not ignorign namespaces. That's why you see required ns prefixes in XPath expressions.\r\n\r\n### Navigation, XPath and Callback support ###\r\n\r\n#### Raw XPath ####\r\n\r\nYou can execute RAW XPath directly through Java Xpath API by using `rawXpath` methods:\r\n\r\n * Boolan XMLTag.rawXpathBoolean(...)\r\n * Number XMLTag.rawXpathNumber(...)\r\n * String XMLTag.rawXpathString(...)\r\n * Node XMLTag.rawXpathNode(...)\r\n * NodeList XMLTag.rawXpathNodeSet(...)\r\n\r\n#### Gotos ####\r\n\r\nNavigation in the document is achieved by `gotos` methods\r\n\r\n__gotoParent__\r\n\r\nReturns to the parent tag, or remain to the root tag if we are already in the root tag.\r\n\r\n__gotoRoot__\r\n\r\nAs it says, goes to the root tag.\r\n\r\n__gotoChild__\r\n\r\nGoes to the only existing child of a tag. It is just a useful method to traverse XML document from child to child when there are only one child per element. If you call this method when you are in a tag that does not contain exactly one child element, the method will throw an exception.\r\n\r\n__gotoChild(int i)__\r\n\r\nGoes to the Nth child of the current element. Index is from 1 up to `child number`, exactly like XPath array selection (child[i]) If the child at given position does not exist, an exception is thrown.\r\n\r\n__gotoChild(String name)__\r\n\r\nGoes to to the unique existing child element having given name. If there is no child with this name, or if there are more than one, an exception will be thrown.\r\n\r\n__gotoTag(String relativeXpath, Object... arguments)__\r\n\r\nGoes to to a tag element given an XPath expression. `arguments` is useful to parametrize the XPath expression with namespace prefixes for example. It uses String.format(). Remember when using XPath on a document with namespaces, you must always use prefixes even when the document has a default namespace.\r\n\r\n__Example:__\r\n\r\nGiven:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n    <html xmlns=\"http://www.w3.org/2002/06/xhtml2/\" xmlns:w=\"http://wicket.sourceforge.net/wicket-1.0\">\r\n        <head>\r\n            <title w:id=\"title\"/>\r\n        </head>\r\n        <body>\r\n            <w:border>\r\n                <div/>\r\n                child1\r\n            </w:border>\r\n            <w:border>child2</w:border>\r\n            <w:border>child3</w:border>\r\n        </body>\r\n    </html>\r\n\r\nWe can browse the above document like this:\r\n\r\n    XMLTag doc = XMLDoc.from(getClass().getResource(\"/goto.xml\"), false);\r\n            String ns = doc.getPefix(\"http://www.w3.org/2002/06/xhtml2/\");\r\n            doc.gotoChild(\"head\")      // jump to the only 'head' tag under 'html'\r\n                    .gotoChild()       // jump to the only child of 'head'\r\n                    .gotoRoot()        // go to 'html'\r\n                    .gotoChild(2)      // go to child 'body'\r\n                    .gotoChild(3)      // go to third child 'w:border' having text 'child3'\r\n                    .gotoRoot()        // return to root\r\n                    .gotoTag(\"%1$s:body/w:border[1]/%1$s:div\", ns); // xpath navigation with namespace\r\n\r\nNotice the Xpath expression when we use namespace: as we load an existing document, we can get generated prefix for a namespace with the `getPrefix` method. Then we can use this generated prefix in our XPath. `%1$s` means that we take the first argument provided (see String.format() documentation). If you debug, you will see that the XPath expression is `ns0:body/w:border[1]/ns0:div`.\r\n\r\n#### Callbacks on selected nodes ####\r\n\r\nCallbacks: `forEach`, `forEachChilds`\r\n\r\nXMLTool enables you to execute callback actions for each node selected or each child nodes.\r\n\r\n__Example:__\r\n\r\nIf we take back the XHTML example:\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n    <!DOCTYPE html\r\n            PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\r\n            \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\r\n    <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\r\n    <head>\r\n        <title>my title</title>\r\n    </head>\r\n    <body>\r\n        <div id=\"header\" class=\"banner\"></div>\r\n        <div id=\"content\" class=\"cool\"></div>\r\n        <div id=\"footer\" class=\"end\"></div>\r\n    </body>\r\n    </html>\r\n\r\nAnd we execute:\r\n\r\n    XMLDoc.from(getClass().getResource(\"/test.xhtml\"), true).forEachChild(new CallBack() {\r\n        public void execute(XMLTag doc) {\r\n            System.out.println(doc.getCurrentTagName());\r\n        }\r\n\r\n    XMLDoc.from(getClass().getResource(\"/test.xhtml\"), true).forEach(new CallBack() {\r\n        public void execute(XMLTag doc) {\r\n            System.out.println(doc.getAttribute(\"id\"));\r\n        }\r\n    }, \"//div\");\r\n\r\nWe obtain:\r\n\r\n    head\r\n    body\r\n    header\r\n    content\r\n    footer\r\n\r\n### Converting your XML document ###\r\n\r\nDocument conversion is done through `to*` methods.\r\n\r\n__toDocument__\r\n\r\nConverts to an org.w3c.dom.Document instance.\r\n\r\n__toString__\r\n__toString(String encoding)__\r\n\r\nConverts to a formatted string, optionally giving an encoding. \r\n\r\n__toBytes__\r\n\r\nConvert to a byte array\r\n\r\n__toResult__, __toStream__\r\n\r\nConverts to streams. \r\n\r\n__Example:__\r\n\r\n    XMLDoc.newDocument(true).addRoot(\"html\")\r\n        .toResult(new DOMResult())\r\n        .toStream(new StringWriter())\r\n        .toStream(new ByteArrayOutputStream());\r\n\r\n### Validating your XML document ###\r\n\r\nXML validation enables to validate current document against a shema. Of course, to use this functionnality you need to create a document that does not ignore namespaces.\r\n\r\n__validate__\r\n\r\nThis method is used to validate the document against schemas. It returns a ValidationResult instance containing all warning and error issued during validation.\r\n\r\n__Example:__\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n    <html xmlns=\"http://www.w3.org/2002/06/xhtml2/\" xmlns:w=\"http://wicket.sourceforge.net/wicket-1.0\">\r\n        <head>\r\n            <title w:id=\"title\"/>\r\n        </head>\r\n        <body>\r\n            <w:border>\r\n                <div/>\r\n                child1\r\n            </w:border>\r\n            <w:border>child2</w:border>\r\n            <w:border>child3</w:border>\r\n        </body>\r\n    </html>\r\n\r\n * Namespace http://www.w3.org/2002/06/xhtml2/ is defined in schema http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd\r\n * Namespace http://wicket.sourceforge.net/wicket-1.0 is defined in schema http://wicket.sourceforge.net/wicket-1.0.xsd\r\n\r\nIf we validate the XML document goto.xml seen above:\r\n\r\n    ValidationResult results = XMLDoc.from(getClass().getResource(\"/goto.xml\")).validate(\r\n            new URL(\"http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd\"),\r\n            new URL(\"http://wicket.sourceforge.net/wicket-1.0.xsd\")\r\n    );\r\n    assertFalse(results.hasError());\r\n\r\nIf we validate the following document created by us below:\r\n\r\n    results = XMLDoc.newDocument()\r\n            .addDefaultNamespace(\"http://www.w3.org/2002/06/xhtml2/\")\r\n            .addRoot(\"htmlZZ\")\r\n            .validate(new URL(\"http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd\"));\r\n    assertTrue(results.hasError());\r\n    System.out.println(Arrays.deepToString(results.getErrorMessages()));\r\n\r\nThe output is:\r\n\r\n    [cvc-elt.1: Cannot find the declaration of element 'htmlxxx'.]\r\n\r\n### Exception handling ###\r\n\r\nEach operation causing an exception throws a XMLDocumentException with a described message.\r\n\r\n[![githalytics.com alpha](https://cruel-carlota.pagodabox.com/c89084a008d60a2378ce0b480d883d8e \"githalytics.com\")](http://githalytics.com/mycila/xmltool)\r\n","google":"UA-5669052-12","note":"Don't delete this file! It's used internally to help with page regeneration."}